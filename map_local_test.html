<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OASIS â€” Ghana Healthcare Intelligence</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v3.9.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.9.0/mapbox-gl.css' rel='stylesheet' />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- ElevenLabs Conversational AI Widget -->
    <script src="https://elevenlabs.io/convai-widget/index.js" async type="text/javascript"></script>
    <style>
        :root {
            --accent: #FF6B35;
            --accent-glow: rgba(255,107,53,0.4);
            --accent-soft: rgba(255,107,53,0.15);
            --cyan: #00D4FF;
            --green: #00E676;
            --red: #FF5252;
            --yellow: #FFD740;
            --glass: rgba(10,12,20,0.82);
            --glass-border: rgba(255,255,255,0.08);
            --t1: #fff;
            --t2: rgba(255,255,255,0.6);
            --t3: rgba(255,255,255,0.35);
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family:'Inter',system-ui,sans-serif; overflow:hidden; background:#000; }
        #map { position:absolute; inset:0; }

        /* â”€â”€ Glass panels â”€â”€ */
        .glass {
            background: var(--glass);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
        }

        /* â”€â”€ Top bar â”€â”€ */
        .top-bar {
            position:absolute; top:20px; left:50%; transform:translateX(-50%);
            z-index:1000; padding:12px 28px;
            display:flex; align-items:center; gap:12px;
        }
        .top-bar .logo {
            width:32px; height:32px;
            background:linear-gradient(135deg,var(--accent),#FF8F6B);
            border-radius:8px; display:flex; align-items:center; justify-content:center;
            font-size:18px;
        }
        .top-bar h1 { font-size:18px; font-weight:700; color:var(--t1); letter-spacing:2px; }
        .top-bar .sub { font-size:11px; color:var(--t2); letter-spacing:0.5px; }
        .status-dot {
            width:8px; height:8px; border-radius:50%; background:var(--green); margin-left:8px;
            animation: pulse-dot 2s infinite;
        }
        @keyframes pulse-dot {
            0%,100%{box-shadow:0 0 0 0 rgba(0,230,118,0.7)} 50%{box-shadow:0 0 0 6px rgba(0,230,118,0)}
        }

        /* â”€â”€ Left sidebar â”€â”€ */
        .sidebar {
            position:absolute; top:80px; left:20px; width:340px; z-index:1000;
            max-height:calc(100vh - 100px); overflow-y:auto;
            scrollbar-width:thin; scrollbar-color:rgba(255,255,255,0.1) transparent;
        }
        .sidebar::-webkit-scrollbar{width:4px}
        .sidebar::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.1);border-radius:2px}

        .section { padding:20px; }
        .section + .section { border-top:1px solid var(--glass-border); }
        .section-label {
            font-size:10px; font-weight:700; text-transform:uppercase;
            letter-spacing:1.5px; color:var(--t3); margin-bottom:12px;
        }
        .section-title { font-size:16px; font-weight:700; color:var(--t1); margin-bottom:4px; }
        .section-desc { font-size:12px; color:var(--t2); line-height:1.5; margin-bottom:16px; }

        /* â”€â”€ Inputs â”€â”€ */
        .select-wrap { position:relative; margin-bottom:12px; }
        .select-wrap select {
            width:100%; padding:12px 16px;
            background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.1);
            border-radius:10px; color:var(--t1); font-size:14px; font-family:inherit;
            outline:none; appearance:none; cursor:pointer; transition:all 0.3s;
        }
        .select-wrap select:focus { border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-soft); }
        .select-wrap select option { background:#1a1a2e; color:#fff; }
        .select-wrap::after { content:'â–¾'; position:absolute; right:14px; top:50%; transform:translateY(-50%); color:var(--t3); pointer-events:none; }

        .input-wrap { position:relative; margin-bottom:12px; }
        .input-wrap input {
            width:100%; padding:12px 16px 12px 38px;
            background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.1);
            border-radius:10px; color:var(--t1); font-size:14px; font-family:inherit;
            outline:none; transition:all 0.3s;
        }
        .input-wrap input:focus { border-color:var(--accent); box-shadow:0 0 0 3px var(--accent-soft); }
        .input-wrap input::placeholder { color:var(--t3); }
        .input-wrap .icon { position:absolute; left:12px; top:50%; transform:translateY(-50%); font-size:14px; color:var(--t3); }

        .range-row { display:flex; align-items:center; gap:12px; margin-bottom:12px; }
        .range-row label { font-size:11px; color:var(--t2); white-space:nowrap; }
        .range-row input[type=range] {
            flex:1; -webkit-appearance:none; height:4px;
            background:rgba(255,255,255,0.1); border-radius:2px; outline:none;
        }
        .range-row input[type=range]::-webkit-slider-thumb {
            -webkit-appearance:none; width:18px; height:18px;
            background:var(--accent); border-radius:50%; cursor:pointer;
            box-shadow:0 0 8px var(--accent-glow);
        }
        .range-val { min-width:50px; text-align:right; font-size:14px; font-weight:600; color:var(--accent); }

        /* â”€â”€ Buttons â”€â”€ */
        .btn-primary {
            width:100%; padding:14px;
            background:linear-gradient(135deg,var(--accent),#FF8F6B);
            color:#fff; border:none; border-radius:10px;
            font-size:14px; font-weight:700; font-family:inherit;
            cursor:pointer; transition:all 0.3s;
            display:flex; align-items:center; justify-content:center; gap:8px;
            letter-spacing:0.5px; text-transform:uppercase;
        }
        .btn-primary:hover { transform:translateY(-2px); box-shadow:0 8px 24px var(--accent-glow); }
        .btn-primary:disabled { opacity:0.5; cursor:wait; transform:none; }

        .btn-sm {
            padding:10px; background:rgba(255,255,255,0.06);
            color:var(--t2); border:1px solid rgba(255,255,255,0.1);
            border-radius:8px; font-size:12px; font-weight:600;
            font-family:inherit; cursor:pointer; transition:all 0.3s;
        }
        .btn-sm:hover { background:rgba(255,255,255,0.1); color:var(--t1); }

        /* â”€â”€ Result cards â”€â”€ */
        .result-card {
            padding:14px; background:rgba(255,255,255,0.03);
            border:1px solid rgba(255,255,255,0.06);
            border-radius:12px; margin-bottom:10px;
            cursor:pointer; transition:all 0.3s; position:relative;
        }
        .result-card:hover { background:rgba(255,255,255,0.06); border-color:var(--accent); transform:translateX(4px); }
        .result-card.active { border-color:var(--accent); background:var(--accent-soft); }
        .result-card .rank {
            position:absolute; top:-8px; left:-8px;
            width:28px; height:28px;
            background:linear-gradient(135deg,var(--accent),#FF8F6B);
            border-radius:50%; display:flex; align-items:center; justify-content:center;
            font-size:12px; font-weight:800; color:#fff;
            box-shadow:0 2px 8px var(--accent-glow);
        }
        .result-card .name { font-size:14px; font-weight:600; color:var(--t1); margin-bottom:4px; padding-left:18px; }
        .result-card .meta { font-size:11px; color:var(--t2); display:flex; gap:12px; margin-bottom:8px; }
        .match-bar { height:4px; background:rgba(255,255,255,0.06); border-radius:2px; overflow:hidden; }
        .match-fill { height:100%; border-radius:2px; transition:width 1s ease; }
        .match-label { display:flex; justify-content:space-between; margin-bottom:4px; }
        .match-label span:first-child { font-size:10px; color:var(--t3); text-transform:uppercase; letter-spacing:1px; }
        .match-label span:last-child { font-size:12px; font-weight:700; }
        .tags { display:flex; flex-wrap:wrap; gap:4px; margin-top:8px; }
        .tag {
            padding:2px 8px; background:rgba(0,212,255,0.1);
            border:1px solid rgba(0,212,255,0.2); border-radius:4px;
            font-size:9px; color:var(--cyan); text-transform:uppercase; letter-spacing:0.5px;
        }

        /* â”€â”€ Bottom detail card â”€â”€ */
        .detail-card {
            position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
            width:min(800px, calc(100% - 400px)); z-index:1000;
            display:none; overflow:hidden;
        }
        .detail-card.show { display:block; animation:slideUp 0.4s ease; }
        @keyframes slideUp { from{transform:translateX(-50%) translateY(20px);opacity:0} to{transform:translateX(-50%) translateY(0);opacity:1} }

        .detail-header {
            padding:16px 20px; display:flex; justify-content:space-between; align-items:flex-start;
            border-bottom:1px solid var(--glass-border);
        }
        .detail-header h2 { font-size:18px; font-weight:700; color:var(--t1); }
        .type-badge {
            padding:4px 12px; background:var(--accent-soft);
            border:1px solid rgba(255,107,53,0.3); border-radius:20px;
            font-size:11px; font-weight:600; color:var(--accent);
            text-transform:uppercase; letter-spacing:0.5px;
        }
        .close-btn {
            width:28px; height:28px; background:rgba(255,255,255,0.06);
            border:none; border-radius:6px; color:var(--t2); font-size:16px;
            cursor:pointer; display:flex; align-items:center; justify-content:center;
        }
        .close-btn:hover { background:rgba(255,255,255,0.1); color:var(--t1); }

        .detail-stats {
            padding:16px 20px; display:grid; grid-template-columns:1fr 1fr 1fr; gap:20px;
        }
        .stat-block { text-align:center; }
        .stat-val { font-size:28px; font-weight:800; color:var(--t1); }
        .stat-lbl { font-size:10px; color:var(--t3); text-transform:uppercase; letter-spacing:1px; margin-top:2px; }
        .detail-caps {
            padding:12px 20px 16px; border-top:1px solid var(--glass-border);
        }
        .detail-caps h4 { font-size:10px; color:var(--t3); text-transform:uppercase; letter-spacing:1px; margin-bottom:8px; }
        .cap-chips { display:flex; flex-wrap:wrap; gap:6px; }
        .cap-chip {
            padding:4px 10px; background:rgba(0,212,255,0.08);
            border:1px solid rgba(0,212,255,0.15); border-radius:6px;
            font-size:11px; color:var(--cyan);
        }

        /* â”€â”€ Layer toggles â”€â”€ */
        .layers {
            position:absolute; bottom:20px; right:20px; z-index:1000;
            display:flex; flex-direction:column; gap:8px;
        }
        .layer-btn {
            width:44px; height:44px; border-radius:12px;
            display:flex; align-items:center; justify-content:center;
            font-size:18px; cursor:pointer; border:none; position:relative;
            color:var(--t2); background:var(--glass);
            backdrop-filter:blur(24px); border:1px solid var(--glass-border);
            transition:all 0.3s;
        }
        .layer-btn:hover { background:rgba(255,255,255,0.1); color:var(--t1); transform:scale(1.1); }
        .layer-btn.on { background:var(--accent-soft); border-color:var(--accent); color:var(--accent); }
        .layer-btn .tip {
            position:absolute; right:56px; background:var(--glass); border:1px solid var(--glass-border);
            padding:6px 12px; border-radius:8px; font-size:11px; white-space:nowrap;
            opacity:0; pointer-events:none; transition:opacity 0.2s; color:var(--t2);
        }
        .layer-btn:hover .tip { opacity:1; }

        /* â”€â”€ Heatmap legend â”€â”€ */
        .legend {
            position:absolute; bottom:70px; right:20px; z-index:999;
            padding:12px 16px; display:none;
        }
        .legend.show { display:block; }
        .legend h4 { font-size:10px; color:var(--t3); text-transform:uppercase; letter-spacing:1px; margin-bottom:8px; }
        .legend-bar {
            width:160px; height:8px; border-radius:4px;
            background:linear-gradient(90deg,rgba(0,0,0,0) 0%,#1a0530 15%,#6b0f6b 30%,#ff4444 50%,#ff9944 70%,#ffee44 85%,#fff 100%);
            margin-bottom:4px;
        }
        .legend-labels { display:flex; justify-content:space-between; font-size:9px; color:var(--t3); }

        /* â”€â”€ Stats bar â”€â”€ */
        .stats-bar {
            position:absolute; bottom:20px; left:380px; z-index:999;
            padding:8px 16px; display:flex; gap:20px; font-size:11px;
        }
        .stats-bar .s { display:flex; align-items:center; gap:6px; color:var(--t2); }
        .stats-bar .n { font-weight:700; color:var(--t1); }

        /* â”€â”€ Loading â”€â”€ */
        .loader {
            position:fixed; inset:0; background:#000; z-index:9999;
            display:flex; flex-direction:column; align-items:center; justify-content:center;
            transition:opacity 1s;
        }
        .loader.gone { opacity:0; pointer-events:none; }
        .loader-icon {
            width:64px; height:64px;
            background:linear-gradient(135deg,var(--accent),#FF8F6B);
            border-radius:16px; display:flex; align-items:center; justify-content:center;
            font-size:32px; margin-bottom:24px; animation:spin 2s ease infinite;
        }
        @keyframes spin { 0%,100%{transform:rotateY(0)} 50%{transform:rotateY(180deg)} }
        .loader-text { font-size:14px; color:var(--t2); letter-spacing:3px; text-transform:uppercase; }
        .loader-bar { width:200px; height:2px; background:rgba(255,255,255,0.1); border-radius:1px; margin-top:16px; overflow:hidden; }
        .loader-fill { height:100%; background:linear-gradient(90deg,var(--accent),#FF8F6B); border-radius:1px; animation:loadbar 2s ease forwards; }
        @keyframes loadbar { from{width:0} to{width:100%} }

        /* â”€â”€ Mapbox overrides â”€â”€ */
        .mapboxgl-ctrl-bottom-left,.mapboxgl-ctrl-bottom-right{display:none}
        .mapboxgl-popup-content {
            background:var(--glass)!important; backdrop-filter:blur(24px);
            color:var(--t1)!important; border:1px solid var(--glass-border);
            border-radius:12px!important; padding:16px!important;
            box-shadow:0 8px 32px rgba(0,0,0,0.5)!important; min-width:200px;
        }
        .mapboxgl-popup-tip { border-top-color:var(--glass)!important; }
        .mapboxgl-popup-close-button { color:var(--t2)!important; font-size:18px!important; }

        /* â”€â”€ Status message â”€â”€ */
        .api-status {
            position:absolute; top:80px; right:20px; z-index:1000;
            padding:8px 14px; font-size:11px; display:none;
        }
        .api-status.show { display:flex; align-items:center; gap:8px; }
        .api-status.ok { color:var(--green); }
        .api-status.err { color:var(--red); }

        /* â”€â”€ ElevenLabs Avatar Widget â”€â”€ */
        elevenlabs-convai {
            position:fixed; bottom:24px; right:24px; z-index:10000;
        }

        /* â”€â”€ 3D Hospital Spotlight Pulse â”€â”€ */
        @keyframes spotlight-pulse {
            0%,100% { box-shadow:0 0 40px 20px rgba(255,107,53,0.3); }
            50% { box-shadow:0 0 80px 40px rgba(255,107,53,0.6); }
        }
        .hospital-spotlight {
            position:absolute; width:60px; height:60px; border-radius:50%;
            background:radial-gradient(circle,rgba(255,107,53,0.4) 0%,transparent 70%);
            animation:spotlight-pulse 2s ease-in-out infinite;
            pointer-events:none; transform:translate(-50%,-50%);
            z-index:1;
        }

    </style>
</head>
<body>

<div class="loader" id="loader">
    <div class="loader-icon">ğŸŒ</div>
    <div class="loader-text">Initializing OASIS</div>
    <div class="loader-bar"><div class="loader-fill"></div></div>
</div>

<div id="map"></div>

<!-- Top bar -->
<div class="top-bar glass">
    <div class="logo">ğŸŒ</div>
    <div>
        <h1>OASIS</h1>
        <div class="sub">Ghana Healthcare Intelligence Platform</div>
    </div>
    <div class="status-dot" id="status-dot"></div>
</div>

<!-- API status indicator -->
<div class="api-status glass" id="api-status"></div>

<!-- Left sidebar -->
<div class="sidebar glass" id="sidebar">
    <div class="section">
        <div class="section-label">Geospatial Search</div>
        <div class="section-title">Find Healthcare Facilities</div>
        <div class="section-desc">Powered by MCP geospatial tools â€” queries DuckDB with Haversine distance filtering</div>

        <div class="select-wrap">
            <select id="inp-condition">
                <option value="">Select conditionâ€¦</option>
            </select>
        </div>

        <div class="input-wrap">
            <span class="icon">ğŸ“</span>
            <input type="text" id="inp-location" placeholder="Location (e.g. Accra, Kumasi)" value="Accra" />
        </div>

        <div class="range-row">
            <label>Radius</label>
            <input type="range" id="inp-radius" min="10" max="300" value="50" />
            <span class="range-val" id="radius-display">50 km</span>
        </div>

        <button class="btn-primary" id="btn-search" onclick="doSearch()">
            <span>âš¡</span> Find Facilities
        </button>
        
        <button class="btn-sm" onclick="resetGlobe()" style="width:100%; margin-top:8px;">
            âœ• Clear Filters
        </button>
    </div>

    <!-- Coverage gaps button -->
    <div class="section">
        <div class="section-label">Coverage Analysis</div>
        <button class="btn-primary" id="btn-gaps" onclick="doGaps()" style="background:linear-gradient(135deg,#FF5252,#FF8A80);">
            <span>ğŸœï¸</span> Find Medical Deserts
        </button>
    </div>

    <!-- Results -->
    <div class="section" id="results-section" style="display:none;">
        <div class="section-label" id="results-label">Results</div>
        <div id="results-list"></div>
    </div>

    <!-- Quick nav -->
    <div class="section">
        <div class="section-label">Navigate</div>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
            <button class="btn-sm" onclick="flyTo(-0.187,5.6037,13,'Accra')">ğŸ“ Accra</button>
            <button class="btn-sm" onclick="flyTo(-1.6163,6.6885,13,'Kumasi')">ğŸ“ Kumasi</button>
            <button class="btn-sm" onclick="flyTo(-0.8393,9.4008,12,'Tamale')">ğŸ“ Tamale</button>
            <button class="btn-sm" onclick="resetGlobe()">ğŸŒ Globe</button>
        </div>
    </div>
</div>

<!-- Bottom detail -->
<div class="detail-card glass" id="detail-card">
    <div class="detail-header">
        <div>
            <h2 id="d-name">â€”</h2>
            <span class="type-badge" id="d-type">â€”</span>
        </div>
        <button class="close-btn" onclick="closeDetail()">âœ•</button>
    </div>
    <div class="detail-stats">
        <div class="stat-block"><div class="stat-val" id="d-specs">â€”</div><div class="stat-lbl">Specialties</div></div>
        <div class="stat-block"><div class="stat-val" id="d-dist">â€”</div><div class="stat-lbl">Distance</div></div>
        <div class="stat-block"><div class="stat-val" id="d-city">â€”</div><div class="stat-lbl">City</div></div>
    </div>
    <div class="detail-caps">
        <h4>Capabilities</h4>
        <div class="cap-chips" id="d-caps"></div>
    </div>
</div>

<!-- Layer toggles -->
<div class="layers">
    <button class="layer-btn on" id="tog-markers" onclick="toggleLayer('markers')">ğŸ“<span class="tip">Facility Markers</span></button>
    <button class="layer-btn" id="tog-heatmap" onclick="toggleLayer('heatmap')">ğŸ”¥<span class="tip">Coverage Heatmap</span></button>
    <button class="layer-btn" id="tog-buildings" onclick="toggleLayer('buildings')">ğŸ¢<span class="tip">3D Buildings</span></button>
    <button class="layer-btn" id="tog-deserts" onclick="toggleLayer('deserts')">ğŸœï¸<span class="tip">Medical Deserts</span></button>
</div>

<!-- Heatmap legend -->
<div class="legend glass" id="heatmap-legend">
    <h4>Healthcare Capability Density</h4>
    <div class="legend-bar"></div>
    <div class="legend-labels"><span>Desert</span><span>Low</span><span>Moderate</span><span>High</span></div>
</div>

<!-- Stats bar -->
<div class="stats-bar glass" id="stats-bar">
    <div class="s"><span>ğŸ¥</span><span class="n" id="st-total">0</span> Facilities</div>
    <div class="s"><span>ğŸ“</span><span class="n" id="st-cities">0</span> Cities</div>
    <div class="s"><span>ğŸ”¬</span><span class="n" id="st-specs">0</span> Specialties</div>
</div>


<!-- ElevenLabs Conversational AI Avatar Widget -->
<elevenlabs-convai agent-id="5fb47760b0b22b63d689754639894c80b823ed971ff73ced808b98563e1447ce"></elevenlabs-convai>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API keys loaded from .env via /api/config endpoint
let MAPBOX_TOKEN = '';
let ELEVENLABS_API_KEY = '';
const ELEVENLABS_AGENT_ID = '5fb47760b0b22b63d689754639894c80b823ed971ff73ced808b98563e1447ce';
const API_BASE = '';  // same origin when served by map_api.py

// Load API keys from server
(async () => {
    try {
        const res = await fetch('/api/config');
        const config = await res.json();
        MAPBOX_TOKEN = config.mapbox_token || '';
        ELEVENLABS_API_KEY = config.elevenlabs_api_key || '';
        mapboxgl.accessToken = MAPBOX_TOKEN;
        initMap(); // Initialize map after keys are loaded
    } catch (e) {
        console.error('Failed to load API keys:', e);
        alert('âš ï¸ Failed to load API keys. Check .env file and server.');
    }
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let facilitiesGeoJSON = null;
let activeMarkers = [];
let searchResultsCache = [];
let layerState = { markers: true, heatmap: false, buildings: false, deserts: false };
let current3DModel = null;
let audioElement = null;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAP INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let map = null;

function initMap() {
    map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/dark-v11',
    projection: 'globe',
    center: [0, 20],
    zoom: 1.8,
    pitch: 0,
    bearing: 0,
    antialias: true,
});

map.addControl(new mapboxgl.NavigationControl({ visualizePitch: true }), 'top-right');

map.on('style.load', () => {
    map.setFog({
        color: 'rgb(10,10,30)',
        'high-color': 'rgb(30,50,120)',
        'horizon-blend': 0.08,
        'space-color': 'rgb(5,5,15)',
        'star-intensity': 0.95,
    });
});

map.on('load', async () => {
    // 3D terrain
    map.addSource('mapbox-dem', { type: 'raster-dem', url: 'mapbox://mapbox.mapbox-terrain-dem-v1', tileSize: 512, maxzoom: 14 });
    map.setTerrain({ source: 'mapbox-dem', exaggeration: 1.5 });
    map.addLayer({ id: 'sky', type: 'sky', paint: { 'sky-type': 'atmosphere', 'sky-atmosphere-sun': [0,90], 'sky-atmosphere-sun-intensity': 15 } });

    // Load data + build layers
    await loadFacilities();
    addMapLayers();
    populateConditionDropdown();
    checkApiHealth();

    // Intro animation
    setTimeout(() => {
        document.getElementById('loader').classList.add('gone');
        map.flyTo({ center: [-1.0232, 7.9465], zoom: 6.5, pitch: 50, bearing: -15, duration: 4000, essential: true });
    }, 2200);
});
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA LOADING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function loadFacilities() {
    try {
        const resp = await fetch(API_BASE + '/facilities.geojson');
        facilitiesGeoJSON = await resp.json();

        // Compute stats from real data
        const cities = new Set();
        const specs = new Set();
        const allSpecs = [];
        facilitiesGeoJSON.features.forEach(f => {
            const p = f.properties;
            if (p.city) cities.add(p.city);
            try {
                JSON.parse(p.specialties || '[]').forEach(s => { specs.add(s); allSpecs.push(s); });
            } catch(e) {}
        });

        document.getElementById('st-total').textContent = facilitiesGeoJSON.features.length;
        document.getElementById('st-cities').textContent = cities.size;
        document.getElementById('st-specs').textContent = specs.size;

        // Store unique specialties for dropdown
        window._allSpecialties = [...specs].sort();

    } catch (err) {
        console.error('Failed to load facilities.geojson:', err);
    }
}

function populateConditionDropdown() {
    const sel = document.getElementById('inp-condition');
    if (!window._allSpecialties) return;
    window._allSpecialties.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s;
        opt.textContent = fmtSpec(s);
        sel.appendChild(opt);
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER: Convert Point to Polygon for 3D extrusion
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function pointToPolygon(lng, lat, radius = 0.0008) {
    // Creates a circular polygon ~90m in radius
    const points = 32;
    const coords = [];
    for (let i = 0; i <= points; i++) {
        const angle = (i / points) * 2 * Math.PI;
        coords.push([
            lng + radius * Math.cos(angle),
            lat + radius * Math.sin(angle)
        ]);
    }
    return coords;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAP LAYERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function addMapLayers() {
    if (!facilitiesGeoJSON) return;

    // Convert Point geometries to circular Polygons for 3D extrusion
    // fill-extrusion requires Polygon geometry, not Points!
    const facilitiesPolygons = {
        type: 'FeatureCollection',
        features: facilitiesGeoJSON.features.map(f => {
            if (f.geometry.type === 'Point') {
                const [lng, lat] = f.geometry.coordinates;
                return {
                    ...f,
                    geometry: {
                        type: 'Polygon',
                        coordinates: [pointToPolygon(lng, lat)]
                    }
                };
            }
            return f;
        })
    };

    console.log('ğŸ—ºï¸ Adding map sources:', facilitiesGeoJSON.features.length, 'facilities');
    console.log('ğŸ—ï¸ Creating 3D polygon source for', facilitiesPolygons.features.length, '3D buildings');

    // Use original Points for markers, Polygons for 3D buildings
    map.addSource('facilities', { type: 'geojson', data: facilitiesGeoJSON });
    map.addSource('facilities-3d', { type: 'geojson', data: facilitiesPolygons });

    // Heatmap â€” weighted by specialty count (more specialties = hotter)
    map.addLayer({
        id: 'layer-heatmap', type: 'heatmap', source: 'facilities',
        layout: { visibility: 'none' },
        paint: {
            'heatmap-weight': ['interpolate',['linear'],['length',['to-string',['get','specialties']]],10,0.2,100,0.5,300,1],
            'heatmap-intensity': ['interpolate',['linear'],['zoom'],0,1,9,3],
            'heatmap-radius': ['interpolate',['linear'],['zoom'],0,4,6,30,9,50],
            'heatmap-color': ['interpolate',['linear'],['heatmap-density'],
                0,'rgba(0,0,0,0)',0.1,'rgba(26,5,48,0.6)',0.25,'rgba(107,15,107,0.7)',
                0.4,'rgba(255,68,68,0.8)',0.6,'rgba(255,153,68,0.85)',0.8,'rgba(255,238,68,0.9)',1,'rgba(255,255,255,1)'
            ],
            'heatmap-opacity': ['interpolate',['linear'],['zoom'],5,0.8,12,0.3],
        }
    }, 'waterway-label');

    // Glow layer
    map.addLayer({
        id: 'layer-glow', type: 'circle', source: 'facilities',
        paint: {
            'circle-radius': ['interpolate',['linear'],['zoom'],4,6,8,12,12,18],
            'circle-color': '#FF6B35', 'circle-opacity': 0.15, 'circle-blur': 1,
        }
    });

    // 3D Hospital Models (extruded buildings) - ALWAYS VISIBLE
    // Uses 'facilities-3d' source which has Polygon geometry (required for extrusion)
    map.addLayer({
        id: 'layer-3d-hospitals',
        type: 'fill-extrusion',
        source: 'facilities-3d', // Use polygon source for 3D extrusion
        minzoom: 6, // Start showing 3D buildings earlier
        paint: {
            'fill-extrusion-color': [
                'interpolate', ['linear'], ['zoom'],
                6, '#FF6B35',
                10, '#FF7B45',
                15, '#FF8F6B'
            ],
            'fill-extrusion-height': [
                'interpolate', ['exponential', 1.5], ['zoom'],
                6, 10,    // Small buildings when zoomed out
                10, 40,   // Medium buildings at mid zoom
                14, 100,  // Larger buildings when closer
                18, 250   // Very tall when zoomed in
            ],
            'fill-extrusion-base': 0,
            'fill-extrusion-opacity': [
                'interpolate', ['linear'], ['zoom'],
                6, 0.7,   // Semi-transparent when far
                10, 0.85, // More solid as you zoom in
                14, 0.95
            ],
            'fill-extrusion-vertical-gradient': true
        }
    }, 'layer-buildings');
    
    // Markers (flat circles ONLY when zoomed out - overlap with 3D for smooth transition)
    map.addLayer({
        id: 'layer-markers', type: 'circle', source: 'facilities',
        minzoom: 4,
        maxzoom: 12, // Extend a bit for smooth transition
        paint: {
            'circle-radius': ['interpolate',['linear'],['zoom'],4,2.5,8,5,10,8,12,4],
            'circle-color': '#FF6B35', 
            'circle-opacity': [
                'interpolate', ['linear'], ['zoom'],
                4, 0.85,
                10, 0.6,  // Fade out as 3D buildings appear
                12, 0
            ],
            'circle-stroke-width': ['interpolate',['linear'],['zoom'],4,0.5,10,2,12,1],
            'circle-stroke-color': 'rgba(255,255,255,0.6)', 
            'circle-blur': 0.1,
        }
    });

    // 3D Buildings (from Mapbox vector tiles)
    const labelLayer = map.getStyle().layers.find(l => l.type === 'symbol' && l.layout['text-field']);
    map.addLayer({
        id: 'layer-buildings', source: 'composite', 'source-layer': 'building',
        filter: ['==', 'extrude', 'true'], type: 'fill-extrusion', minzoom: 13,
        layout: { visibility: 'none' },
        paint: {
            'fill-extrusion-color': ['interpolate',['linear'],['get','height'],0,'#1a1a3e',20,'#2a2a5e',50,'#4a3a7e'],
            'fill-extrusion-height': ['interpolate',['linear'],['zoom'],13,0,14.5,['get','height']],
            'fill-extrusion-base': ['interpolate',['linear'],['zoom'],13,0,14.5,['get','min_height']],
            'fill-extrusion-opacity': 0.75,
        }
    }, labelLayer ? labelLayer.id : undefined);

    // Click handlers for both 2D markers and 3D models
    const handleFacilityClick = (e) => {
        e.preventDefault();
        const f = e.features[0];
        
        // Use the EXACT facility coordinates from GeoJSON, not the click position
        // This ensures the 3D pin aligns perfectly with the 2D marker
        const facilityCoords = f.geometry.coordinates;
        const lngLat = { lng: facilityCoords[0], lat: facilityCoords[1] };
        
        console.log('ğŸ–±ï¸ Facility clicked:', f.properties.name, 'at exact coords', facilityCoords);
        
        // Pass both lngLat and geometry to showDetail
        const props = {
            ...f.properties,
            geometry: f.geometry, // Include geometry for coordinate extraction
            coords: facilityCoords // Use exact facility coordinates
        };
        
        // showDetail triggers 3D model + narration
        showDetail(props, lngLat);
    };
    
    map.on('click', 'layer-markers', handleFacilityClick);
    map.on('click', 'layer-3d-hospitals', handleFacilityClick);

    map.on('mouseenter', 'layer-markers', () => { map.getCanvas().style.cursor = 'pointer'; });
    map.on('mouseleave', 'layer-markers', () => { map.getCanvas().style.cursor = ''; });
    map.on('mouseenter', 'layer-3d-hospitals', () => { map.getCanvas().style.cursor = 'pointer'; });
    map.on('mouseleave', 'layer-3d-hospitals', () => { map.getCanvas().style.cursor = ''; });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEARCH â€” calls the REAL API (which calls real MCP tools)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function doSearch() {
    const condition = document.getElementById('inp-condition').value;
    const location  = document.getElementById('inp-location').value.trim();
    const radius    = parseInt(document.getElementById('inp-radius').value);

    if (!condition) return alert('Select a condition first');

    const btn = document.getElementById('btn-search');
    btn.disabled = true;
    btn.innerHTML = 'âŸ³ Querying toolsâ€¦';

    try {
        const url = `${API_BASE}/api/search?` + new URLSearchParams({
            condition, location, radius_km: radius, limit: 20
        });
        const resp = await fetch(url);
        const json = await resp.json();

        if (!json.success) throw new Error(json.error || 'Tool returned error');

        const data = json.data;
        console.log(`âœ… ${json.tool} returned ${data.total_found} results in ${json.elapsed_ms}ms`);

        // Build result features from real tool output
        const results = data.facilities.map(f => ({
            coords: [f.lng, f.lat],
            distance: f.distance_km,
            name: f.name,
            city: f.city,
            region: f.region,
            facility_type: f.facility_type,
            specialties: f.specialties,
            equipment: f.equipment,
            capability: f.capability,
        }));

        searchResultsCache = results;
        renderResults(results, condition, data.total_found);

        // Fly to search center
        const ctr = [data.center.lng, data.center.lat];
        map.flyTo({ center: ctr, zoom: 8, pitch: 45, duration: 2000 });
        drawRadius(ctr, radius);
        
        // Replace map with ONLY filtered results
        replaceMapWithResults(results);
        highlightResults(results);
        
        // Update stats
        document.getElementById('st-total').textContent = data.total_found;

    } catch (err) {
        console.error('Search failed:', err);
        showApiStatus(`Search failed: ${err.message}`, false);
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span>âš¡</span> Find Facilities';
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COVERAGE GAPS â€” calls the REAL API (find_coverage_gaps tool)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function doGaps() {
    const condition = document.getElementById('inp-condition').value;
    if (!condition) return alert('Select a condition first');

    const btn = document.getElementById('btn-gaps');
    btn.disabled = true;
    btn.innerHTML = 'âŸ³ Scanningâ€¦';

    try {
        const url = `${API_BASE}/api/gaps?` + new URLSearchParams({
            specialty: condition, min_gap_km: 50, limit: 15
        });
        const resp = await fetch(url);
        const json = await resp.json();

        if (!json.success) throw new Error(json.error || 'Tool returned error');

        const data = json.data;
        console.log(`âœ… ${json.tool} found ${data.gap_count} gaps in ${json.elapsed_ms}ms`);

        // Show gaps on map
        renderDesertGaps(data.gaps);
        showApiStatus(`Found ${data.gap_count} coverage gaps for ${fmtSpec(condition)}`, true);

    } catch (err) {
        console.error('Coverage gap search failed:', err);
        showApiStatus(`Gaps failed: ${err.message}`, false);
    } finally {
        btn.disabled = false;
        btn.innerHTML = '<span>ğŸœï¸</span> Find Medical Deserts';
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER RESULTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderResults(results, condition, totalFromTool) {
    const section = document.getElementById('results-section');
    const list = document.getElementById('results-list');
    const label = document.getElementById('results-label');

    section.style.display = 'block';
    label.textContent = `${totalFromTool} found â€” ${fmtSpec(condition)}`;

    if (results.length === 0) {
        list.innerHTML = `<div style="text-align:center;padding:20px;color:var(--t3);"><div style="font-size:32px;margin-bottom:8px;">ğŸœï¸</div><div>No facilities found</div><div style="font-size:11px;margin-top:4px;">Try a larger radius</div></div>`;
        return;
    }

    list.innerHTML = results.slice(0, 10).map((r, i) => {
        let specs = [];
        try { specs = JSON.parse(r.specialties || '[]'); } catch(e){}
        const score = Math.min(99, Math.round(85 - r.distance * 0.3 + Math.min(15, specs.length * 2)));
        const color = score > 80 ? 'var(--green)' : score > 50 ? 'var(--accent)' : 'var(--yellow)';
        const bar = score > 80 ? 'linear-gradient(90deg,#00E676,#69F0AE)' : score > 50 ? 'linear-gradient(90deg,#FF6B35,#FF8F6B)' : 'linear-gradient(90deg,#FFD740,#FFE57F)';

        return `
            <div class="result-card" id="rc-${i}" onclick="selectResult(${i})">
                <div class="rank">${i+1}</div>
                <div class="name">${r.name}</div>
                <div class="meta">
                    <span>ğŸ“ ${r.distance.toFixed(1)} km</span>
                    <span>ğŸ¥ ${r.facility_type || 'â€”'}</span>
                    <span>ğŸ™ï¸ ${r.city || 'â€”'}</span>
                </div>
                <div class="match-label"><span>Relevance</span><span style="color:${color}">${score}%</span></div>
                <div class="match-bar"><div class="match-fill" style="width:${score}%;background:${bar};"></div></div>
                ${specs.length ? `<div class="tags">${specs.slice(0,4).map(s=>`<span class="tag">${fmtSpec(s)}</span>`).join('')}${specs.length>4?`<span class="tag">+${specs.length-4}</span>`:''}</div>` : ''}
            </div>`;
    }).join('');
}

function selectResult(i) {
    document.querySelectorAll('.result-card').forEach(c => c.classList.remove('active'));
    document.getElementById(`rc-${i}`).classList.add('active');
    const r = searchResultsCache[i];
    if (!r) return;
    const lngLat = { lng: r.coords[0], lat: r.coords[1] };
    map.flyTo({ center: r.coords, zoom: 16, pitch: 60, bearing: Math.random()*60-30, duration: 2000 });
    if (!layerState.buildings) toggleLayer('buildings');
    showDetail(r, lngLat);
}

function replaceMapWithResults(results) {
    console.log('ğŸ¯ Filtering map to show', results.length, 'matching facilities');
    
    // Build GeoJSON from search results ONLY
    const filteredGeoJSON = {
        type: 'FeatureCollection',
        features: results.map(r => ({
            type: 'Feature',
            geometry: { type: 'Point', coordinates: r.coords },
            properties: {
                name: r.name,
                city: r.city,
                region: r.region,
                facility_type: r.facility_type,
                specialties: r.specialties,
                equipment: r.equipment,
                capability: r.capability,
                distance: r.distance,
            }
        }))
    };
    
    // Convert Points to Polygons for 3D extrusion
    const filteredPolygons = {
        type: 'FeatureCollection',
        features: results.map(r => {
            const [lng, lat] = r.coords;
            return {
                type: 'Feature',
                geometry: { type: 'Polygon', coordinates: [pointToPolygon(lng, lat)] },
                properties: {
                    name: r.name,
                    city: r.city,
                    region: r.region,
                    facility_type: r.facility_type,
                    specialties: r.specialties,
                    equipment: r.equipment,
                    capability: r.capability,
                    distance: r.distance,
                }
            };
        })
    };
    
    // Update BOTH sources to show ONLY these facilities
    map.getSource('facilities').setData(filteredGeoJSON);
    map.getSource('facilities-3d').setData(filteredPolygons);
    console.log('âœ… Map updated with', results.length, '3D buildings');
}

function resetMapToAllFacilities() {
    console.log('ğŸ”„ Resetting map to show all', facilitiesGeoJSON?.features.length || 0, 'facilities');
    
    // Restore all facilities
    if (facilitiesGeoJSON) {
        map.getSource('facilities').setData(facilitiesGeoJSON);
        
        // Also restore the 3D polygons
        const allPolygons = {
            type: 'FeatureCollection',
            features: facilitiesGeoJSON.features.map(f => {
                const [lng, lat] = f.geometry.coordinates;
                return {
                    ...f,
                    geometry: {
                        type: 'Polygon',
                        coordinates: [pointToPolygon(lng, lat)]
                    }
                };
            })
        };
        map.getSource('facilities-3d').setData(allPolygons);
        console.log('âœ… All 3D buildings restored');
    }
}

function highlightResults(results) {
    activeMarkers.forEach(m => m.remove());
    activeMarkers = [];
    results.slice(0, 10).forEach((r, i) => {
        const el = document.createElement('div');
        el.style.cssText = `width:${i===0?18:14}px;height:${i===0?18:14}px;border-radius:50%;background:${i===0?'var(--green)':'var(--accent)'};border:2px solid rgba(255,255,255,0.8);cursor:pointer;box-shadow:0 0 12px ${i===0?'rgba(0,230,118,0.6)':'var(--accent-glow)'};`;
        activeMarkers.push(new mapboxgl.Marker(el).setLngLat(r.coords).addTo(map));
    });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDER COVERAGE GAPS (from real tool)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function renderDesertGaps(gaps) {
    // Remove old layer
    if (map.getSource('desert-gaps')) {
        if (map.getLayer('desert-circles')) map.removeLayer('desert-circles');
        if (map.getLayer('desert-labels')) map.removeLayer('desert-labels');
        map.removeSource('desert-gaps');
    }

    const features = gaps.map(g => ({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [g.lng, g.lat] },
        properties: {
            nearest_city: g.nearest_city,
            distance_km: g.nearest_facility_distance_km,
            severity: g.severity,
            nearest_facility: g.nearest_facility_name,
        }
    }));

    map.addSource('desert-gaps', { type: 'geojson', data: { type: 'FeatureCollection', features } });

    map.addLayer({
        id: 'desert-circles', type: 'circle', source: 'desert-gaps',
        paint: {
            'circle-radius': ['interpolate',['linear'],['zoom'],4,20,8,40,12,60],
            'circle-color': ['case', ['==',['get','severity'],'critical'], 'rgba(255,82,82,0.25)', 'rgba(255,152,0,0.2)'],
            'circle-blur': 0.6,
            'circle-stroke-width': 2,
            'circle-stroke-color': ['case', ['==',['get','severity'],'critical'], 'rgba(255,82,82,0.5)', 'rgba(255,152,0,0.4)'],
        }
    }, 'layer-glow');

    map.addLayer({
        id: 'desert-labels', type: 'symbol', source: 'desert-gaps',
        layout: {
            'text-field': ['concat', 'DESERT\n', ['get','nearest_city']],
            'text-size': 10, 'text-anchor': 'center',
        },
        paint: { 'text-color': '#FF5252', 'text-halo-color': '#000', 'text-halo-width': 1 },
    });

    // Fly to see all gaps
    if (gaps.length > 0) {
        const bounds = new mapboxgl.LngLatBounds();
        gaps.forEach(g => bounds.extend([g.lng, g.lat]));
        map.fitBounds(bounds, { padding: 80, pitch: 30, duration: 2000 });
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DETAIL CARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showDetail(props, lngLat) {
    document.getElementById('d-name').textContent = props.name || 'â€”';
    document.getElementById('d-type').textContent = props.facility_type || 'Facility';

    let specs = [];
    try { specs = JSON.parse(props.specialties || '[]'); } catch(e){}
    document.getElementById('d-specs').textContent = specs.length;
    document.getElementById('d-dist').textContent = props.distance != null ? props.distance.toFixed(1) + ' km' : 'â€”';
    document.getElementById('d-city').textContent = props.city || 'â€”';

    let equip = [];
    try { equip = JSON.parse(props.equipment || '[]').filter(Boolean); } catch(e){}
    const chips = [...specs.map(fmtSpec), ...equip];
    document.getElementById('d-caps').innerHTML = chips.slice(0,12).map(c => `<span class="cap-chip">${c}</span>`).join('') + (chips.length > 12 ? `<span class="cap-chip">+${chips.length-12}</span>` : '');

    document.getElementById('detail-card').classList.add('show');
    
    // Extract coordinates - PRIORITIZE the exact click position (lngLat)
    // This is the most accurate as it's where the user actually clicked
    let coords;
    if (lngLat && typeof lngLat.lng === 'number' && typeof lngLat.lat === 'number') {
        // Use the exact click position - Mapbox LngLat object [lng, lat]
        coords = [lngLat.lng, lngLat.lat];
        console.log('ğŸ“ Using EXACT click position:', coords);
    } else if (props.geometry && props.geometry.coordinates && Array.isArray(props.geometry.coordinates)) {
        // GeoJSON coordinates are [lng, lat]
        coords = props.geometry.coordinates;
        console.log('ğŸ“ Using geometry coordinates:', coords);
    } else if (props.coords && Array.isArray(props.coords) && props.coords.length === 2) {
        // Fallback to coords property
        coords = props.coords;
        console.log('ğŸ“ Using props.coords:', coords);
    } else {
        console.error('âŒ No valid coordinates found for facility:', props.name);
        return;
    }
    
    // Ensure coordinates are in [lng, lat] format (Mapbox standard)
    if (coords.length !== 2 || typeof coords[0] !== 'number' || typeof coords[1] !== 'number') {
        console.error('âŒ Invalid coordinate format:', coords);
        return;
    }
    
    console.log('ğŸ“ Showing detail for:', props.name, 'at EXACT coords [lng, lat]:', coords);
    
    // Cinematic camera fly-in to hospital
    cinematicFlyTo(coords, props.name || 'Hospital');
    
    // Add 3D hospital model after camera starts moving (model will rise as camera approaches)
    // Wait a bit longer to ensure map is ready and camera is zooming in
    setTimeout(() => {
        console.log('ğŸ¥ Adding 3D model at:', coords);
        add3DHospitalModel(coords, props.name || 'Hospital');
    }, 1000);
    
    // Narrate with ElevenLabs TTS
    narrateFacility(props);
}

function closeDetail() { 
    document.getElementById('detail-card').classList.remove('show'); 
    // Keep 3D model and pin visible when zoomed in (don't remove it)
    // The pin helps users know where the hospital is located
    // Stop audio
    if (audioElement) {
        audioElement.pause();
        audioElement = null;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LAYER TOGGLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function toggleLayer(name) {
    layerState[name] = !layerState[name];
    const on = layerState[name];
    document.getElementById(`tog-${name}`).classList.toggle('on', on);

    switch(name) {
        case 'markers':
            map.setLayoutProperty('layer-markers', 'visibility', on ? 'visible' : 'none');
            map.setLayoutProperty('layer-3d-hospitals', 'visibility', on ? 'visible' : 'none');
            map.setLayoutProperty('layer-glow', 'visibility', on ? 'visible' : 'none');
            break;
        case 'heatmap':
            map.setLayoutProperty('layer-heatmap', 'visibility', on ? 'visible' : 'none');
            document.getElementById('heatmap-legend').classList.toggle('show', on);
            break;
        case 'buildings':
            map.setLayoutProperty('layer-buildings', 'visibility', on ? 'visible' : 'none');
            break;
        case 'deserts':
            if (map.getLayer('desert-circles')) {
                map.setLayoutProperty('desert-circles', 'visibility', on ? 'visible' : 'none');
                map.setLayoutProperty('desert-labels', 'visibility', on ? 'visible' : 'none');
            } else if (on) {
                // If no gaps loaded yet, trigger the tool
                doGaps();
            }
            break;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEARCH RADIUS CIRCLE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function drawRadius(center, km) {
    if (map.getSource('search-radius')) {
        map.removeLayer('radius-fill');
        map.removeLayer('radius-line');
        map.removeSource('search-radius');
    }
    const pts = 64, coords = [];
    for (let i = 0; i <= pts; i++) {
        const a = (i / pts) * 2 * Math.PI;
        const dx = km / 111.32 * Math.cos(a);
        const dy = km / (111.32 * Math.cos(center[1] * Math.PI / 180)) * Math.sin(a);
        coords.push([center[0] + dy, center[1] + dx]);
    }
    map.addSource('search-radius', { type: 'geojson', data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [coords] } } });
    map.addLayer({ id: 'radius-fill', type: 'fill', source: 'search-radius', paint: { 'fill-color': 'rgba(0,212,255,0.06)' } }, 'layer-glow');
    map.addLayer({ id: 'radius-line', type: 'line', source: 'search-radius', paint: { 'line-color': 'rgba(0,212,255,0.4)', 'line-width': 2, 'line-dasharray': [3,3] } });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NAVIGATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function flyTo(lng, lat, zoom, name) {
    map.flyTo({ center: [lng, lat], zoom, pitch: 60, bearing: -15, duration: 2500 });
    if (!layerState.buildings) toggleLayer('buildings');
}

function resetGlobe() {
    closeDetail();
    resetMapToAllFacilities();
    
    // Clear search results
    document.getElementById('results-section').style.display = 'none';
    activeMarkers.forEach(m => m.remove());
    activeMarkers = [];
    searchResultsCache = [];
    
    // Remove search radius
    if (map.getSource('search-radius')) {
        map.removeLayer('radius-fill');
        map.removeLayer('radius-line');
        map.removeSource('search-radius');
    }
    
    // Restore stats
    if (facilitiesGeoJSON) {
        document.getElementById('st-total').textContent = facilitiesGeoJSON.features.length;
    }
    
    map.flyTo({ center: [-1.0232, 7.9465], zoom: 6.5, pitch: 45, bearing: -15, duration: 3000 });
    if (layerState.buildings) toggleLayer('buildings');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UTILITIES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function fmtSpec(s) { return s.replace(/([A-Z])/g, ' $1').replace(/^./, c => c.toUpperCase()).trim(); }

document.getElementById('inp-radius').addEventListener('input', e => {
    document.getElementById('radius-display').textContent = e.target.value + ' km';
});

// Auto-show buildings on deep zoom
map.on('zoom', () => { if (map.getZoom() >= 14 && !layerState.buildings) toggleLayer('buildings'); });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CINEMATIC CAMERA FLY-IN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function cinematicFlyTo(coords, name) {
    // Enable buildings layer automatically
    if (!layerState.buildings) toggleLayer('buildings');
    
    // Ensure coords are in [lng, lat] format for Mapbox
    let centerCoords;
    if (Array.isArray(coords) && coords.length === 2) {
        // GeoJSON coordinates are [lng, lat], which is what Mapbox expects
        centerCoords = [Number(coords[0]), Number(coords[1])]; // Ensure numbers
    } else {
        console.error('âŒ Invalid coordinates for flyTo:', coords);
        return;
    }
    
    console.log('ğŸ¥ Flying to EXACT coordinates [lng, lat]:', centerCoords);
    
    // Add a temporary marker to show exactly where we're centering
    const marker = new mapboxgl.Marker({ color: '#FF6B35', scale: 1.5 })
        .setLngLat(centerCoords)
        .addTo(map);
    setTimeout(() => marker.remove(), 3000); // Remove after 3 seconds
    
    // Dramatic camera sequence: zoom in with orbit, centered EXACTLY on the point
    map.flyTo({
        center: centerCoords, // Exact coordinates [lng, lat] - this is the clicked point
        zoom: 18.5, // Higher zoom to see the building clearly
        pitch: 75, // Steeper pitch to see the building from above
        bearing: map.getBearing() + 40, // Slight rotation for cinematic effect
        duration: 2500,
        essential: true,
        curve: 1.8, // Smooth curve
    });
    
    // Double-check after animation completes
    map.once('moveend', () => {
        const currentCenter = map.getCenter();
        const distance = Math.sqrt(
            Math.pow(currentCenter.lng - centerCoords[0], 2) + 
            Math.pow(currentCenter.lat - centerCoords[1], 2)
        );
        console.log('âœ… Camera centered. Distance from target:', (distance * 111320).toFixed(2), 'meters');
    });
    
    // Wait for camera to finish before adding 3D model (handled in showDetail)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 3D HOSPITAL MODEL (three.js) â€” Animated modern hospital
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function add3DHospitalModel(coords, name) {
    console.log('ğŸ¥ Adding 3D hospital model at:', coords, name);
    
    if (!window.THREE) { 
        console.error('âŒ THREE.js not loaded! Waiting...');
        setTimeout(() => add3DHospitalModel(coords, name), 500);
        return;
    }
    
    if (!map || !map.isStyleLoaded()) {
        console.warn('âš ï¸ Map not ready, waiting...');
        setTimeout(() => add3DHospitalModel(coords, name), 500);
        return;
    }
    
    // Validate coordinates
    if (!Array.isArray(coords) || coords.length !== 2 || !coords[0] || !coords[1]) {
        console.error('âŒ Invalid coordinates:', coords);
        return;
    }
    
    // Remove old 3D model layer first to prevent conflicts
    if (current3DModel && map.getLayer(current3DModel)) {
        console.log('ğŸ—‘ï¸ Removing old 3D model layer:', current3DModel);
        try {
            map.removeLayer(current3DModel);
            if (map.getSource(current3DModel + '-source')) {
                map.removeSource(current3DModel + '-source');
            }
        } catch (e) {
            console.warn('âš ï¸ Error removing old layer:', e);
        }
    }
    
    const merc = mapboxgl.MercatorCoordinate.fromLngLat(coords, 0);
    console.log('ğŸ“ Mercator coords:', merc.x, merc.y, merc.z);
    const modelTransform = {
        translateX: merc.x, translateY: merc.y, translateZ: merc.z,
        rotateX: Math.PI / 2, rotateY: 0, rotateZ: 0,
        scale: merc.meterInMercatorCoordinateUnits()
    };
    
    const THREE = window.THREE;
    const layerId = '3d-model-hospital-' + Date.now(); // Unique ID to prevent conflicts
    current3DModel = layerId;
    
    const customLayer = {
        id: layerId, type: 'custom', renderingMode: '3d',
        onAdd: function (map, gl) {
            this.camera = new THREE.Camera();
            this.scene = new THREE.Scene();
            this.clock = new THREE.Clock();
            this.riseProgress = 0; // Animation: 0 â†’ 1 rise from ground
            
            // â”€â”€ Atmospheric Lighting â”€â”€
            this.scene.add(new THREE.AmbientLight(0xccddff, 0.5));
            const sun = new THREE.DirectionalLight(0xfffaf0, 1.2);
            sun.position.set(60, -100, 150);
            sun.castShadow = true;
            this.scene.add(sun);
            const rim = new THREE.DirectionalLight(0x88bbff, 0.3);
            rim.position.set(-80, 50, 60);
            this.scene.add(rim);
            const warm = new THREE.PointLight(0xFF6B35, 0.8, 300);
            warm.position.set(0, -20, 15);
            this.scene.add(warm);
            
            // â”€â”€ Materials â”€â”€
            const wallMat = new THREE.MeshPhongMaterial({ color: 0xf5f5f0, specular: 0x333333, shininess: 40 });
            const glassMat = new THREE.MeshPhongMaterial({ color: 0x66bbff, specular: 0xffffff, shininess: 120, opacity: 0.55, transparent: true });
            const accentMat = new THREE.MeshPhongMaterial({ color: 0xFF6B35, specular: 0xff8855, shininess: 80, emissive: 0x331100, emissiveIntensity: 0.2 });
            const crossMat = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff1100, emissiveIntensity: 0.8 });
            const roofMat = new THREE.MeshPhongMaterial({ color: 0x3a4a5a, specular: 0x111111 });
            const padMat = new THREE.MeshPhongMaterial({ color: 0x2a3a4a });
            const frameMat = new THREE.MeshPhongMaterial({ color: 0x888888, specular: 0xaaaaaa, shininess: 60 });
            
            this.hospital = new THREE.Group();
            
            // â”€â”€ Main tower (modern, ~6 floors) â”€â”€
            const mainBody = new THREE.Mesh(new THREE.BoxGeometry(50, 26, 48), wallMat);
            mainBody.position.set(0, 0, 24);
            this.hospital.add(mainBody);
            
            // â”€â”€ Glass curtain wall (front facade) â”€â”€
            const curtainWall = new THREE.Mesh(new THREE.BoxGeometry(48, 0.3, 44), glassMat);
            curtainWall.position.set(0, -13.2, 24);
            this.hospital.add(curtainWall);
            
            // â”€â”€ Window mullions (horizontal floor lines) â”€â”€
            for (let f = 0; f < 6; f++) {
                const z = 4 + f * 8;
                const mullion = new THREE.Mesh(new THREE.BoxGeometry(50.5, 0.6, 0.3), frameMat);
                mullion.position.set(0, -13.3, z);
                this.hospital.add(mullion);
            }
            // Vertical mullions
            for (let v = -4; v <= 4; v++) {
                const vert = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.6, 44), frameMat);
                vert.position.set(v * 5.5, -13.3, 24);
                this.hospital.add(vert);
            }
            
            // â”€â”€ Back + side glass strips â”€â”€
            for (let f = 0; f < 6; f++) {
                const z = 4 + f * 8;
                const winB = new THREE.Mesh(new THREE.BoxGeometry(46, 0.3, 4), glassMat);
                winB.position.set(0, 13.2, z);
                this.hospital.add(winB);
                const winL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 22, 4), glassMat);
                winL.position.set(-25.2, 0, z);
                this.hospital.add(winL);
                const winR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 22, 4), glassMat);
                winR.position.set(25.2, 0, z);
                this.hospital.add(winR);
            }
            
            // â”€â”€ Lower wing (emergency / outpatient) â”€â”€
            const wing = new THREE.Mesh(new THREE.BoxGeometry(30, 22, 14), wallMat);
            wing.position.set(-40, 0, 7);
            this.hospital.add(wing);
            const wingGlass = new THREE.Mesh(new THREE.BoxGeometry(28, 0.3, 10), glassMat);
            wingGlass.position.set(-40, -11.2, 7);
            this.hospital.add(wingGlass);
            
            // â”€â”€ Emergency entrance with glowing sign â”€â”€
            const emergDoor = new THREE.Mesh(new THREE.BoxGeometry(12, 6, 0.5), new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0xff0000, emissiveIntensity: 0.6, transparent: true, opacity: 0.8 }));
            emergDoor.position.set(-40, -14, 3);
            this.hospital.add(emergDoor);
            
            // â”€â”€ Connector corridor â”€â”€
            const corridor = new THREE.Mesh(new THREE.BoxGeometry(5, 22, 12), glassMat);
            corridor.position.set(-24, 0, 6);
            this.hospital.add(corridor);
            
            // â”€â”€ Accent stripe (brand color wrap at top) â”€â”€
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(51, 27, 2.5), accentMat);
            stripe.position.set(0, 0, 48.5);
            this.hospital.add(stripe);
            
            // â”€â”€ Roof equipment â”€â”€
            const roof = new THREE.Mesh(new THREE.BoxGeometry(54, 29, 0.5), roofMat);
            roof.position.set(0, 0, 50);
            this.hospital.add(roof);
            
            // HVAC units
            for (let i = 0; i < 3; i++) {
                const hvac = new THREE.Mesh(new THREE.BoxGeometry(4, 4, 3), new THREE.MeshPhongMaterial({ color: 0x667788 }));
                hvac.position.set(-15 + i * 15, 8, 51.5);
                this.hospital.add(hvac);
            }
            
            // â”€â”€ Helipad â”€â”€
            const padCircle = new THREE.Mesh(new THREE.CylinderGeometry(9, 9, 0.2, 48), padMat);
            padCircle.rotation.x = Math.PI / 2;
            padCircle.position.set(10, -5, 50.3);
            this.hospital.add(padCircle);
            // Helipad ring
            const padRing = new THREE.Mesh(new THREE.RingGeometry(7, 8.5, 48), new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
            padRing.rotation.x = -Math.PI / 2;
            padRing.position.set(10, -5, 50.5);
            this.hospital.add(padRing);
            // H marking
            const hMat = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 0.3 });
            [[10-2.5, -5, 50.6, 1.2, 7, 0.15], [10+2.5, -5, 50.6, 1.2, 7, 0.15], [10, -5, 50.6, 6, 1.2, 0.15]].forEach(([x,y,z,w,h,d]) => {
                const hPart = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), hMat);
                hPart.position.set(x, y, z);
                this.hospital.add(hPart);
            });
            
            // â”€â”€ Main entrance (glass canopy) â”€â”€
            const canopy = new THREE.Mesh(new THREE.BoxGeometry(14, 10, 0.5), glassMat);
            canopy.position.set(0, -18, 12);
            this.hospital.add(canopy);
            // Canopy supports
            [[-6, -18, 6], [6, -18, 6]].forEach(([x,y,z]) => {
                const col = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 12, 8), frameMat);
                col.rotation.x = Math.PI / 2;
                col.position.set(x, y, z);
                this.hospital.add(col);
            });
            
            // â”€â”€ Red cross (front, illuminated) â”€â”€
            const cH = new THREE.Mesh(new THREE.BoxGeometry(8, 0.3, 2.5), crossMat);
            cH.position.set(0, -13.5, 38);
            this.hospital.add(cH);
            const cV = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.3, 8), crossMat);
            cV.position.set(0, -13.5, 38);
            this.hospital.add(cV);
            
            // â”€â”€ Pulsing beacon â”€â”€
            this.beacon = new THREE.PointLight(0xff0000, 2, 250);
            this.beacon.position.set(0, 0, 55);
            this.hospital.add(this.beacon);
            // Beacon visual sphere
            const beaconSphere = new THREE.Mesh(
                new THREE.SphereGeometry(0.8, 16, 16),
                new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 1.0, transparent: true, opacity: 0.9 })
            );
            beaconSphere.position.copy(this.beacon.position);
            this.hospital.add(beaconSphere);
            this.beaconSphere = beaconSphere;
            
            // â”€â”€ 3D Pin/Marker on top of building (always visible when zoomed in) â”€â”€
            const pinGroup = new THREE.Group();
            const pinMat = new THREE.MeshPhongMaterial({ 
                color: 0xFF6B35, 
                emissive: 0xFF6B35, 
                emissiveIntensity: 0.6, // Brighter
                specular: 0xffffff,
                shininess: 60
            });
            const pinGlowMat = new THREE.MeshPhongMaterial({ 
                color: 0xFF6B35, 
                emissive: 0xFF6B35, 
                emissiveIntensity: 1.0, // Brighter glow
                transparent: true,
                opacity: 0.7
            });
            
            // Pin base (cone shape) - larger for better visibility
            const pinBase = new THREE.Mesh(
                new THREE.ConeGeometry(3.5, 10, 16), // Bigger
                pinMat
            );
            pinBase.rotation.x = Math.PI;
            pinBase.position.set(0, 0, 50.5);
            pinGroup.add(pinBase);
            
            // Pin top (sphere) - larger for better visibility
            const pinTop = new THREE.Mesh(
                new THREE.SphereGeometry(3.0, 16, 16), // Bigger
                pinMat
            );
            pinTop.position.set(0, 0, 55.5); // Higher
            pinGroup.add(pinTop);
            
            // Glow ring around pin - larger
            const pinGlow = new THREE.Mesh(
                new THREE.TorusGeometry(3.5, 0.4, 8, 16), // Bigger
                pinGlowMat
            );
            pinGlow.rotation.x = Math.PI / 2;
            pinGlow.position.set(0, 0, 53);
            pinGroup.add(pinGlow);
            
            // Pin shadow/ring on roof - larger
            const pinShadow = new THREE.Mesh(
                new THREE.RingGeometry(3.5, 5, 16), // Bigger
                new THREE.MeshPhongMaterial({ color: 0x000000, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
            );
            pinShadow.rotation.x = -Math.PI / 2;
            pinShadow.position.set(0, 0, 50.1);
            pinGroup.add(pinShadow);
            
            this.hospital.add(pinGroup);
            this.pinGroup = pinGroup; // Store reference for animation
            
            // â”€â”€ Ground platform with subtle glow and clear marker â”€â”€
            const ground = new THREE.Mesh(
                new THREE.CylinderGeometry(55, 60, 0.4, 64),
                new THREE.MeshPhongMaterial({ color: 0x2a3a2a, transparent: true, opacity: 0.7 })
            );
            ground.rotation.x = Math.PI / 2;
            ground.position.set(0, 0, -0.2);
            this.hospital.add(ground);
            
            // â”€â”€ Bright ground marker to show exact position â”€â”€
            const groundMarker = new THREE.Mesh(
                new THREE.CircleGeometry(8, 32),
                new THREE.MeshBasicMaterial({ 
                    color: 0xFF6B35, 
                    transparent: true, 
                    opacity: 0.9,
                    side: THREE.DoubleSide 
                })
            );
            groundMarker.rotation.x = -Math.PI / 2;
            groundMarker.position.set(0, 0, 0.1); // Just above ground
            this.hospital.add(groundMarker);
            this.groundMarker = groundMarker;
            
            // â”€â”€ Particle ring (floating lights around building) â”€â”€
            this.particles = [];
            const particleMat = new THREE.MeshBasicMaterial({ color: 0xFF6B35, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 20; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), particleMat.clone());
                const angle = (i / 20) * Math.PI * 2;
                p.userData.angle = angle;
                p.userData.radius = 35 + Math.random() * 10;
                p.userData.speed = 0.3 + Math.random() * 0.3;
                p.userData.zBase = 10 + Math.random() * 30;
                p.userData.zAmp = 5 + Math.random() * 10;
                this.hospital.add(p);
                this.particles.push(p);
            }
            
            // Start with hospital underground (for rise animation)
            this.hospital.position.z = -0.06; // will animate to 0
            this.scene.add(this.hospital);
            
            this.map = map;
            this.renderer = new THREE.WebGLRenderer({ canvas: map.getCanvas(), context: gl, antialias: true });
            this.renderer.autoClear = false;
            
            console.log('ğŸ—ï¸ 3D Hospital building constructed and ready to render');
        },
        render: function (gl, matrix) {
            const THREE = window.THREE;
            if (!this.clock) return;
            const t = this.clock.getElapsedTime();
            
            // Log first render
            if (!this._hasRendered) {
                console.log('ğŸ¨ 3D building is now rendering!');
                this._hasRendered = true;
            }
            
            // â”€â”€ Rise animation (0 â†’ 1 over 2 seconds) â”€â”€
            if (this.riseProgress < 1) {
                this.riseProgress = Math.min(1, this.riseProgress + 0.015);
                const ease = 1 - Math.pow(1 - this.riseProgress, 3); // ease-out cubic
                this.hospital.position.z = -0.06 * (1 - ease);
                this.hospital.scale.z = 0.01 + ease * 0.99; // scale from flat to full height
            }
            
            // â”€â”€ Pulsing beacon â”€â”€
            if (this.beacon) {
                this.beacon.intensity = 1.5 + Math.sin(t * 4) * 1.5;
                if (this.beaconSphere) {
                    this.beaconSphere.material.opacity = 0.5 + Math.sin(t * 4) * 0.4;
                    this.beaconSphere.scale.setScalar(0.8 + Math.sin(t * 4) * 0.3);
                }
            }
            
            // â”€â”€ Animated pin/marker (pulsing and rotating) â”€â”€
            if (this.pinGroup) {
                // Gentle pulsing scale
                const pulseScale = 1 + Math.sin(t * 2) * 0.1;
                this.pinGroup.scale.setScalar(pulseScale);
                
                // Slow rotation for visibility
                this.pinGroup.rotation.z = t * 0.3;
                
                // Slight vertical bounce (pinGroup is at hospital center, so we add bounce to z)
                const bounce = Math.sin(t * 1.5) * 0.5;
                this.pinGroup.position.z = bounce; // Pin base is at 50.5 relative to pinGroup, so this adds bounce
            }
            
            // â”€â”€ Pulsing ground marker â”€â”€
            if (this.groundMarker) {
                const groundPulse = 1 + Math.sin(t * 3) * 0.3;
                this.groundMarker.scale.setScalar(groundPulse);
                this.groundMarker.material.opacity = 0.6 + Math.sin(t * 3) * 0.3;
            }
            
            // â”€â”€ Orbiting particles â”€â”€
            if (this.particles) {
                this.particles.forEach(p => {
                    const angle = p.userData.angle + t * p.userData.speed;
                    p.position.x = Math.cos(angle) * p.userData.radius;
                    p.position.y = Math.sin(angle) * p.userData.radius;
                    p.position.z = p.userData.zBase + Math.sin(t * 1.5 + p.userData.angle) * p.userData.zAmp;
                    p.material.opacity = 0.3 + Math.sin(t * 2 + p.userData.angle) * 0.5;
                });
            }
            
            const rX = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(1,0,0), modelTransform.rotateX);
            const rY = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0,1,0), modelTransform.rotateY);
            const rZ = new THREE.Matrix4().makeRotationAxis(new THREE.Vector3(0,0,1), modelTransform.rotateZ);
            
            const m = new THREE.Matrix4().fromArray(matrix);
            const l = new THREE.Matrix4()
                .makeTranslation(modelTransform.translateX, modelTransform.translateY, modelTransform.translateZ)
                .scale(new THREE.Vector3(modelTransform.scale, -modelTransform.scale, modelTransform.scale))
                .multiply(rX).multiply(rY).multiply(rZ);
            
            this.camera.projectionMatrix = m.multiply(l);
            this.renderer.resetState();
            this.renderer.render(this.scene, this.camera);
            this.map.triggerRepaint();
        }
    };
    
    // Wait for map style to be loaded before adding custom layer
    if (map.isStyleLoaded()) {
        try {
            map.addLayer(customLayer);
            console.log('âœ… 3D hospital model layer added:', name);
            
            // Verify it was added
            setTimeout(() => {
                if (map.getLayer(layerId)) {
                    console.log('âœ… 3D building confirmed visible at:', coords);
                } else {
                    console.error('âŒ Layer not found after adding!');
                }
            }, 100);
        } catch (err) {
            console.error('âŒ Error adding 3D layer:', err);
            // If layer already exists, try removing and re-adding
            if (err.message && err.message.includes('already exists')) {
                console.log('ğŸ”„ Layer exists, removing and re-adding...');
                try {
                    map.removeLayer(layerId);
                    if (map.getSource(layerId + '-source')) {
                        map.removeSource(layerId + '-source');
                    }
                    setTimeout(() => add3DHospitalModel(coords, name), 100);
                } catch (e2) {
                    console.error('âŒ Failed to recover:', e2);
                }
            }
        }
    } else {
        console.warn('âš ï¸ Map style not loaded, waiting...');
        map.once('style.load', () => {
            setTimeout(() => add3DHospitalModel(coords, name), 100);
        });
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ELEVENLABS NARRATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function narrateFacility(props) {
    console.log('ğŸ”Š Starting ElevenLabs narration for:', props.name);
    
    // Stop previous audio
    if (audioElement) {
        audioElement.pause();
        audioElement = null;
    }
    
    if (!ELEVENLABS_API_KEY || ELEVENLABS_API_KEY === 'YOUR_ELEVENLABS_API_KEY') {
        console.log('âš ï¸ ElevenLabs API key not set');
        return;
    }
    
    // Build narration text
    let specs = [];
    try { specs = JSON.parse(props.specialties || '[]'); } catch(e) {}
    
    const text = `${props.name || 'This facility'}. ${props.city ? 'Located in ' + props.city + '.' : ''} ${
        specs.length > 0 ? 'Specialties include ' + specs.slice(0, 3).map(s => s.replace(/([A-Z])/g, ' $1')).join(', ') + '.' : ''
    }`;
    
    try {
        const response = await fetch('https://api.elevenlabs.io/v1/text-to-speech/21m00Tcm4TlvDq8ikWAM', {
            method: 'POST',
            headers: {
                'Accept': 'audio/mpeg',
                'Content-Type': 'application/json',
                'xi-api-key': ELEVENLABS_API_KEY
            },
            body: JSON.stringify({
                text: text,
                model_id: 'eleven_monolingual_v1',
                voice_settings: {
                    stability: 0.5,
                    similarity_boost: 0.5
                }
            })
        });
        
        if (response.ok) {
            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            audioElement = new Audio(audioUrl);
            audioElement.play();
            console.log('âœ… ElevenLabs audio playing');
        } else {
            console.error('âŒ ElevenLabs API error:', response.status, await response.text());
        }
    } catch (err) {
        console.error('âŒ ElevenLabs error:', err);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API HEALTH CHECK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function checkApiHealth() {
    try {
        const r = await fetch(API_BASE + '/api/health');
        const j = await r.json();
        if (j.status === 'ok') {
            showApiStatus(`Connected â€” dataset: ${j.dataset}`, true);
            document.getElementById('status-dot').style.background = 'var(--green)';
        } else {
            throw new Error(j.error);
        }
    } catch (e) {
        showApiStatus('API not connected â€” run: python map_api.py', false);
        document.getElementById('status-dot').style.background = 'var(--red)';
    }
}

function showApiStatus(msg, ok) {
    const el = document.getElementById('api-status');
    el.textContent = (ok ? 'âœ… ' : 'âš ï¸ ') + msg;
    el.className = `api-status glass show ${ok ? 'ok' : 'err'}`;
    setTimeout(() => { el.classList.remove('show'); }, 5000);
}
</script>
</body>
</html>
